---
phase: 02-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - .github/problem-matchers/tsc.json
  - scripts/setup-branch-protection.sh
autonomous: true

must_haves:
  truths:
    - "Pushing to main or opening a PR targeting main triggers the CI workflow"
    - "Draft PRs do NOT trigger CI (job-level condition skips them)"
    - "Lint errors from Biome appear as inline annotations on PR files"
    - "TypeScript errors appear as inline annotations on PR files"
    - "Tests run with coverage and check-coverage.ts enforces 80% threshold"
    - "Coverage report appears as a PR comment via zgosalvez/github-actions-report-lcov"
    - "Coverage badge is updated on push to main via Schneegans/dynamic-badges-action"
    - "Doc-only PRs are not blocked by path filtering (dorny/paths-filter at step level, not paths-ignore at workflow level)"
    - "Branch protection script blocks direct push and force push to main, requires CI status check"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "CI workflow with lint, typecheck, test, coverage"
      contains: "biome ci . --reporter=github"
    - path: ".github/problem-matchers/tsc.json"
      provides: "TypeScript error annotations in PR files"
      contains: "problemMatcher"
    - path: "scripts/setup-branch-protection.sh"
      provides: "Automated branch protection configuration via gh CLI"
      contains: "gh api"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: ".github/problem-matchers/tsc.json"
      via: "::add-matcher:: directive in typecheck step"
      pattern: "add-matcher.*problem-matchers/tsc.json"
    - from: ".github/workflows/ci.yml"
      to: "scripts/check-coverage.ts"
      via: "bun run step after tests"
      pattern: "bun run scripts/check-coverage.ts"
    - from: "scripts/setup-branch-protection.sh"
      to: ".github/workflows/ci.yml"
      via: "required_status_checks context matches job name"
      pattern: "contexts.*CI"
---

<objective>
Create the GitHub Actions CI workflow, TypeScript problem matcher, and branch protection script for the passive-docs-index project.

Purpose: Automate code quality validation on every push/PR so that lint errors, type errors, and test failures are caught before merge.
Output: Three files -- CI workflow (`.github/workflows/ci.yml`), tsc problem matcher (`.github/problem-matchers/tsc.json`), and branch protection script (`scripts/setup-branch-protection.sh`).
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ci-cd-pipeline/02-RESEARCH.md
@.planning/phases/02-ci-cd-pipeline/02-CONTEXT.md
@package.json
@biome.jsonc
@tsconfig.json
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CI workflow and tsc problem matcher</name>
  <files>.github/workflows/ci.yml, .github/problem-matchers/tsc.json</files>
  <action>
Create `.github/workflows/ci.yml` with:

**Triggers:**
- `push` to `main` branch
- `pull_request` targeting `main` with types: `[opened, synchronize, reopened, ready_for_review]`
- Do NOT use `paths-ignore` at workflow level (breaks required status checks -- see research pitfall #1)

**Job: `ci`**
- `name: CI` (this name must match the required status check in branch protection script)
- `runs-on: ubuntu-latest`
- `if: github.event.pull_request.draft == false || github.event_name == 'push'` (excludes draft PRs per user decision)
- `permissions:` `contents: read`, `pull-requests: write`

**Steps (in order):**

1. **Checkout** -- `actions/checkout@v4`

2. **Setup Bun** -- `oven-sh/setup-bun@v2` (no version pin, uses latest per user decision)

3. **Install dependencies** -- `bun install`

4. **Check for code changes** -- `dorny/paths-filter@v3` with id `changes`
   - Filter named `code` matching: `src/**`, `scripts/**`, `tests/**`, `package.json`, `tsconfig.json`, `biome.jsonc`, `bunfig.toml`
   - This allows doc-only PRs to pass through without running checks (user decision: path filtering active)

5. **Lint** -- `bunx biome ci . --reporter=github`
   - Condition: `if: steps.changes.outputs.code == 'true'`
   - Uses `biome ci` directly (not `ultracite check`) to get `--reporter=github` for inline annotations per user decision

6. **Typecheck** -- Two-line run block:
   ```
   echo "::add-matcher::.github/problem-matchers/tsc.json"
   bun run typecheck
   ```
   - Condition: `if: steps.changes.outputs.code == 'true'`
   - The add-matcher registers the tsc problem matcher for inline annotations per user decision

7. **Test with coverage** -- `bun test --coverage`
   - Condition: `if: steps.changes.outputs.code == 'true'`

8. **Check coverage thresholds** -- `bun run scripts/check-coverage.ts`
   - Condition: `if: steps.changes.outputs.code == 'true'`
   - Reuses existing Phase 1 script (80% per-module threshold)

9. **Report coverage on PR** -- `zgosalvez/github-actions-report-lcov@v4`
   - Condition: `if: github.event_name == 'pull_request' && steps.changes.outputs.code == 'true'`
   - Inputs: `coverage-files: coverage/lcov.info`, `minimum-coverage: 80`, `github-token: ${{ secrets.GITHUB_TOKEN }}`, `update-comment: true`
   - Per user decision: coverage report as automatic PR comment with threshold 80%

10. **Extract coverage percentage** -- Bash script (only on push to main)
    - Condition: `if: github.ref == 'refs/heads/main' && github.event_name == 'push' && steps.changes.outputs.code == 'true'`
    - id: `coverage`
    - Parse lcov.info with awk to compute total line coverage percentage
    - Output to `$GITHUB_OUTPUT` as `percentage`

11. **Update coverage badge** -- `schneegans/dynamic-badges-action@v1.7.0`
    - Condition: `if: github.ref == 'refs/heads/main' && github.event_name == 'push' && steps.changes.outputs.code == 'true'`
    - Inputs: `auth: ${{ secrets.GIST_SECRET }}`, `gistID: ${{ vars.COVERAGE_GIST_ID }}`, `filename: coverage.json`, `label: Coverage`, `message: ${{ steps.coverage.outputs.percentage }}%`, `valColorRange: ${{ steps.coverage.outputs.percentage }}`, `maxColorRange: 90`, `minColorRange: 50`
    - NOTE: Use `${{ vars.COVERAGE_GIST_ID }}` (repository variable) instead of hardcoding, so the Gist ID can be configured without code changes. Add a YAML comment explaining the one-time setup: create a Gist, create PAT with `gist` scope, add `GIST_SECRET` as repo secret and `COVERAGE_GIST_ID` as repo variable.

Also create `.github/problem-matchers/tsc.json` with the TypeScript problem matcher from the research:
```json
{
  "problemMatcher": [
    {
      "owner": "tsc",
      "pattern": [
        {
          "regexp": "^([^\\s].*)[\\(:](\\d+)[,:](\\d+)(?:\\):\\s+|\\s+-\\s+)(error|warning|info)\\s+TS(\\d+)\\s*:\\s*(.*)$",
          "file": 1,
          "line": 2,
          "column": 3,
          "severity": 4,
          "code": 5,
          "message": 6
        }
      ]
    }
  ]
}
```
  </action>
  <verify>
- File `.github/workflows/ci.yml` exists and is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"`
- File `.github/problem-matchers/tsc.json` exists and is valid JSON: `python3 -c "import json; json.load(open('.github/problem-matchers/tsc.json'))"`
- Workflow contains `biome ci . --reporter=github` (lint annotations)
- Workflow contains `add-matcher` referencing tsc.json (typecheck annotations)
- Workflow contains `dorny/paths-filter` (path filtering at step level)
- Workflow does NOT contain `paths-ignore` at top level
- Workflow contains draft PR exclusion condition
- Workflow contains `zgosalvez/github-actions-report-lcov` (PR coverage comment)
- Workflow contains `schneegans/dynamic-badges-action` (coverage badge)
  </verify>
  <done>
CI workflow file triggers on push to main and PRs targeting main. Draft PRs are excluded via job-level condition. Sequential steps run lint (with GitHub annotations), typecheck (with problem matcher annotations), tests with coverage, coverage threshold check, PR coverage comment, and coverage badge update. Path filtering via dorny/paths-filter ensures doc-only PRs succeed without running checks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create branch protection script</name>
  <files>scripts/setup-branch-protection.sh</files>
  <action>
Create `scripts/setup-branch-protection.sh` as an executable bash script:

```bash
#!/usr/bin/env bash
set -euo pipefail
```

Constants:
- `OWNER="syx-labs"`, `REPO="passive-docs-index"`, `BRANCH="main"`

The script uses `gh api --method PUT` to configure branch protection:
- `required_status_checks[strict]=true` -- require branch to be up-to-date
- `required_status_checks[contexts][]=CI` -- require the CI job to pass (matches job name in ci.yml)
- `enforce_admins=true` -- enforce for admins too (per user decision: direct push to main blocked for everyone)
- `required_pull_request_reviews=null` -- no review required (per user decision: solo project)
- `restrictions=null` -- no push restrictions beyond branch protection
- `allow_force_pushes=false` -- per user decision: force push blocked, history preserved
- `allow_deletions=false` -- prevent branch deletion

Add echo statements before and after the API call showing what's being configured and confirming success.

Make the script executable: `chmod +x scripts/setup-branch-protection.sh`.

Add a comment at the top of the script explaining:
- Prerequisites: `gh` CLI authenticated with repo admin access
- This script is idempotent (safe to re-run)
- Run manually after the CI workflow is pushed and has run at least once
  </action>
  <verify>
- File `scripts/setup-branch-protection.sh` exists
- File is executable: `test -x scripts/setup-branch-protection.sh`
- Script contains `gh api` call with `required_status_checks`
- Script references `CI` as the required context (matches ci.yml job name)
- Script sets `allow_force_pushes=false` and `enforce_admins=true`
- Script has valid bash syntax: `bash -n scripts/setup-branch-protection.sh`
  </verify>
  <done>
Branch protection script exists at `scripts/setup-branch-protection.sh`, is executable, and configures main branch to require CI status check, block direct push, block force push, and enforce for admins. No PR review required (solo project).
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` is valid YAML with all required steps
2. `.github/problem-matchers/tsc.json` is valid JSON with correct regex pattern
3. `scripts/setup-branch-protection.sh` is executable with valid bash syntax
4. No `paths-ignore` at workflow level (would deadlock with branch protection)
5. Draft PR exclusion uses correct pattern: job-level `if` with `draft == false`
6. CI job name is `CI` in both workflow and branch protection script
</verification>

<success_criteria>
- Three files created: ci.yml, tsc.json, setup-branch-protection.sh
- Workflow triggers on push to main + PRs targeting main
- Draft PRs excluded via job-level condition
- Path filtering via dorny/paths-filter at step level (not paths-ignore)
- Lint step uses `biome ci . --reporter=github` for annotations
- Typecheck step registers tsc problem matcher for annotations
- Coverage comment on PRs via zgosalvez/github-actions-report-lcov
- Coverage badge update on push to main via schneegans/dynamic-badges-action
- Branch protection script ready to run (requires gh auth)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ci-cd-pipeline/02-01-SUMMARY.md`
</output>
