---
phase: 04-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli.ts
  - src/lib/error-handler.ts
  - src/lib/context7-client.ts
  - tests/unit/lib/cli-error-handler.test.ts
  - tests/unit/lib/context7-errors.test.ts
autonomous: true

must_haves:
  truths:
    - "cli.ts has a single handleCommandError() function instead of 9 duplicate try-catch blocks"
    - "Context7 auth failures (401, 403, invalid key) show a message mentioning `pdi auth` to reconfigure"
    - "Context7 network failures (timeout, connection refused) show a message about connectivity"
    - "Context7 rate limit responses (429) show a message suggesting to wait"
    - "PDI_DEBUG=1 causes stack traces to appear in error output"
    - "No raw stack traces appear in normal (non-debug) error output for any error type"
  artifacts:
    - path: "src/lib/error-handler.ts"
      provides: "Extracted handleCommandError function for CLI error formatting"
      contains: "handleCommandError"
    - path: "src/cli.ts"
      provides: "CLI with unified error handler imported from error-handler.ts"
      contains: "handleCommandError"
    - path: "src/lib/context7-client.ts"
      provides: "Enhanced Context7 error classification with Context7Error"
      contains: "classifyContext7Error"
    - path: "tests/unit/lib/cli-error-handler.test.ts"
      provides: "Tests for handleCommandError with each error type"
      contains: "handleCommandError"
    - path: "tests/unit/lib/context7-errors.test.ts"
      provides: "Tests for Context7 error classification"
      contains: "classifyContext7Error"
  key_links:
    - from: "src/cli.ts"
      to: "src/lib/errors.ts"
      via: "handleCommandError checks instanceof for each error type"
      pattern: "ConfigError|Context7Error|PDIError|NotInitializedError"
    - from: "src/lib/context7-client.ts"
      to: "src/lib/errors.ts"
      via: "queryViaHttp creates Context7Error from fetch failures"
      pattern: "Context7Error"
---

<objective>
Implement the unified CLI error handler and Context7 error categorization to deliver user-friendly, specific error messages for every failure mode.

Purpose: Completes the error handling story by connecting the error types from Plan 04-01 to the CLI output layer and to Context7 failure handling. This satisfies ERR-01 (all commands with user-friendly messages), ERR-02 (Context7 errors with specific messages and fallback info), and the overall Phase 4 goal of graceful CLI failure.

Output: Refactored cli.ts with unified error handler, enhanced context7-client.ts with error classification, and tests validating error output for each error category.
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-error-handling/04-CONTEXT.md
@.planning/phases/04-error-handling/04-RESEARCH.md
@.planning/phases/04-error-handling/04-01-PLAN.md
@src/cli.ts
@src/lib/errors.ts
@src/lib/config.ts
@src/lib/context7-client.ts
@src/lib/types.ts
@tests/helpers/setup.ts
@tests/helpers/mock-fetch.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Context7 error classification</name>
  <files>
    src/lib/context7-client.ts
  </files>
  <action>
    Add a `classifyContext7Error` function to context7-client.ts that categorizes errors from Context7 operations into Context7Error instances with specific user messages.

    **Create the classification function:**
    ```typescript
    import { Context7Error } from "./errors.js";

    export function classifyContext7Error(
      error: unknown,
      source: "http" | "mcp" | "none"
    ): Context7Error {
      const message = error instanceof Error ? error.message : String(error);
      const cause = error instanceof Error ? error : undefined;
      const lowerMessage = message.toLowerCase();

      // Auth errors (401, 403, invalid key)
      if (
        lowerMessage.includes("401") ||
        lowerMessage.includes("403") ||
        lowerMessage.includes("unauthorized") ||
        lowerMessage.includes("invalid") && lowerMessage.includes("key") ||
        lowerMessage.includes("forbidden")
      ) {
        return new Context7Error(
          "Context7 API key is invalid or expired.",
          {
            category: "auth",
            source,
            hint: "Run `pdi auth` to reconfigure your API key, or set CONTEXT7_API_KEY in your environment.",
            cause,
          }
        );
      }

      // Rate limit (429, too many requests)
      if (
        lowerMessage.includes("429") ||
        lowerMessage.includes("rate limit") ||
        lowerMessage.includes("too many requests")
      ) {
        return new Context7Error(
          "Context7 rate limit reached.",
          {
            category: "rate_limit",
            source,
            hint: "Wait a moment and try again. Consider using `pdi update` with fewer frameworks at once.",
            cause,
          }
        );
      }

      // Network errors (timeout, connection refused, DNS failure)
      if (
        lowerMessage.includes("timeout") ||
        lowerMessage.includes("econnrefused") ||
        lowerMessage.includes("enotfound") ||
        lowerMessage.includes("fetch failed") ||
        lowerMessage.includes("network") ||
        lowerMessage.includes("aborted") ||
        lowerMessage.includes("econnreset")
      ) {
        return new Context7Error(
          "Cannot reach Context7 servers.",
          {
            category: "network",
            source,
            hint: "Check your internet connection. If the issue persists, try again later or use `--offline` mode.",
            cause,
          }
        );
      }

      // Redirect errors
      if (
        lowerMessage.includes("library_redirected") ||
        lowerMessage.includes("redirected")
      ) {
        return new Context7Error(
          "Library ID has changed in Context7.",
          {
            category: "redirect",
            source,
            hint: "Run `pdi add <framework> --force` to update with the new library ID.",
            cause,
          }
        );
      }

      // Not found
      if (
        lowerMessage.includes("no documentation found") ||
        lowerMessage.includes("not found") ||
        lowerMessage.includes("404")
      ) {
        return new Context7Error(
          "No documentation found for this query.",
          {
            category: "not_found",
            source,
            hint: "The library may not be indexed by Context7, or the query returned no results.",
            cause,
          }
        );
      }

      // Unknown/generic
      return new Context7Error(message, {
        category: "unknown",
        source,
        cause,
      });
    }
    ```

    **Update queryViaHttp():**
    In the catch block of `queryViaHttp()` (around line 228), replace the generic error handling with classification. Instead of returning `{ success: false, error: errorMessage, source: "http" }`, use `classifyContext7Error` to create a typed error, but still return the result union (don't throw -- the fallback logic depends on result checking):

    Change the error return to include the classified message:
    ```typescript
    } catch (error) {
      const classified = classifyContext7Error(error, "http");

      // Handle redirect errors with retry (existing logic)
      if (classified.category === "redirect") {
        // ... existing redirect retry logic stays the same ...
      }

      return {
        success: false,
        error: classified.hint
          ? `${classified.message} ${classified.hint}`
          : classified.message,
        source: "http",
      };
    }
    ```

    **Update queryViaMcp():**
    Similarly, in the catch block of `queryViaMcp()`, use classification:
    ```typescript
    } catch (error) {
      const classified = classifyContext7Error(error, "mcp");
      return {
        success: false,
        error: classified.hint
          ? `${classified.message} ${classified.hint}`
          : classified.message,
        source: "mcp",
      };
    }
    ```

    **Update queryContext7() "both failed" message:**
    In the unified client (line ~403), improve the "both failed" error message to be more helpful:
    ```typescript
    return {
      success: false,
      error: httpAvailable
        ? "Documentation fetch failed. Check connection and API key with `pdi doctor`."
        : "No documentation source available. Run `pdi auth` to configure Context7 API, or use `--offline` mode.",
      source: "none",
    };
    ```

    **Important:** Do NOT change the `Context7Result` type or the success/failure flow. The existing callers (add.ts, update.ts) rely on checking `result.success`. The change is only in the error messages returned.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `grep "classifyContext7Error" src/lib/context7-client.ts` finds the function
    3. `grep "Context7Error" src/lib/context7-client.ts` finds the import
    4. `bun test` passes (existing tests should work since error messages changed but flow is same)
  </verify>
  <done>
    Context7 error classification implemented: classifyContext7Error() categorizes errors into auth, network, rate_limit, redirect, not_found, and unknown with specific user messages and actionable hints. Both HTTP and MCP query paths use classification. The "both failed" message is improved with specific guidance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unified CLI error handler</name>
  <files>
    src/cli.ts
  </files>
  <action>
    Refactor cli.ts to replace the 9 duplicate try-catch blocks with a single unified error handler.

    **Create `handleCommandError` function:**
    Add this function to cli.ts (after the imports, before the program definition):

    ```typescript
    import {
      PDIError,
      ConfigError,
      Context7Error,
      NotInitializedError,
    } from "./lib/errors.js";

    /**
     * Unified error handler for all CLI commands.
     * Formats errors based on type and exits with code 1.
     */
    function handleCommandError(error: unknown): never {
      if (error instanceof ConfigError) {
        console.error(chalk.red("Config Error:"), error.message);
        if (error.validationIssues && error.validationIssues.length > 0) {
          console.error(chalk.dim(error.formatValidationIssues()));
        }
        if (error.hint) {
          console.error(chalk.dim(`\nFix: ${error.hint}`));
        }
      } else if (error instanceof NotInitializedError) {
        console.error(chalk.red("Error:"), error.message);
        if (error.hint) {
          console.error(chalk.dim(`\nFix: ${error.hint}`));
        }
      } else if (error instanceof Context7Error) {
        console.error(chalk.red("Context7 Error:"), error.message);
        if (error.hint) {
          console.error(chalk.dim(`\nFix: ${error.hint}`));
        }
      } else if (error instanceof PDIError) {
        console.error(chalk.red("Error:"), error.message);
        if (error.hint) {
          console.error(chalk.dim(`\nFix: ${error.hint}`));
        }
      } else if (error instanceof Error) {
        console.error(
          chalk.red("Error:"),
          error.message
        );
      } else {
        console.error(chalk.red("Error:"), String(error));
      }

      // Show stack trace in debug mode
      if (process.env.PDI_DEBUG && error instanceof Error && error.stack) {
        console.error(chalk.dim("\nStack trace:"));
        console.error(chalk.dim(error.stack));
      }

      process.exit(1);
    }
    ```

    **Create a wrapper helper:**
    To avoid even the repetitive `try { await fn() } catch (e) { handleCommandError(e) }` pattern, create a small wrapper:

    ```typescript
    function wrapCommand(fn: (...args: unknown[]) => Promise<void>) {
      return async (...args: unknown[]) => {
        try {
          await fn(...args);
        } catch (error) {
          handleCommandError(error);
        }
      };
    }
    ```

    **Replace all command action handlers:**
    Replace each command's `.action(async (...) => { try { ... } catch { ... } })` with the wrapper.

    Before:
    ```typescript
    .action(async (options) => {
      try {
        await initCommand(options);
      } catch (error) {
        console.error(chalk.red("Error:"), error instanceof Error ? error.message : error);
        process.exit(1);
      }
    });
    ```

    After:
    ```typescript
    .action(wrapCommand(async (options) => {
      await initCommand(options as InitOptions & Record<string, unknown>);
    }));
    ```

    Or alternatively, if the typing is awkward with the generic wrapper, keep the explicit try-catch but use `handleCommandError`:
    ```typescript
    .action(async (options) => {
      try {
        await initCommand(options);
      } catch (error) {
        handleCommandError(error);
      }
    });
    ```

    The second approach (explicit try-catch with handleCommandError) is simpler and preserves Commander's type inference. **Use this approach.**

    **Apply to all 9 commands:** init, add, sync, status, clean, list (sync -- list doesn't have try-catch currently, leave it), update, generate, auth, doctor.

    **The `list` command:** Currently has no try-catch. It's a synchronous command that just prints templates. Leave it as-is (no async operations, no errors to catch).

    **Remove old error handling pattern:**
    Delete all instances of:
    ```typescript
    console.error(chalk.red("Error:"), error instanceof Error ? error.message : error);
    process.exit(1);
    ```
    Replace with just: `handleCommandError(error);`
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `grep "handleCommandError" src/cli.ts` finds the function and its usage
    3. `grep -c "handleCommandError(error)" src/cli.ts` shows 9 usages (one per command with try-catch)
    4. `grep "process.exit(1)" src/cli.ts` shows only 1 occurrence (inside handleCommandError)
    5. `grep "error instanceof Error ? error.message" src/cli.ts` returns no matches (old pattern removed)
    6. `bun test` passes
  </verify>
  <done>
    CLI error handler unified: single handleCommandError() function handles all error types with appropriate formatting (ConfigError shows validation issues + fix hint, Context7Error shows category-specific message, NotInitializedError shows init instructions, generic Error shows message only). PDI_DEBUG enables stack traces. All 9 command try-catch blocks use the unified handler. No duplicate error handling code remains.
  </done>
</task>

<task type="auto">
  <name>Task 3: Tests for CLI error handler and Context7 error classification</name>
  <files>
    tests/unit/lib/cli-error-handler.test.ts
    tests/unit/lib/context7-errors.test.ts
  </files>
  <action>
    Create tests for the CLI error handler and Context7 error classification.

    **tests/unit/lib/context7-errors.test.ts:**
    Test the `classifyContext7Error` function:

    - Auth errors:
      - Input: `new Error("HTTP 401 Unauthorized")` → category "auth", hint includes "pdi auth"
      - Input: `new Error("403 Forbidden")` → category "auth"
      - Input: `new Error("Invalid API key provided")` → category "auth"

    - Rate limit errors:
      - Input: `new Error("429 Too Many Requests")` → category "rate_limit", hint includes "wait"
      - Input: `new Error("Rate limit exceeded")` → category "rate_limit"

    - Network errors:
      - Input: `new Error("fetch failed")` → category "network", hint includes "internet connection"
      - Input: `new Error("ECONNREFUSED")` → category "network"
      - Input: `new TypeError("Failed to fetch")` → category "network"
      - Input: `new Error("Request timeout")` → category "network"

    - Redirect errors:
      - Input: `new Error("library_redirected to /new/id")` → category "redirect", hint includes "--force"

    - Not found errors:
      - Input: `new Error("No documentation found")` → category "not_found"
      - Input: `new Error("404 Not Found")` → category "not_found"

    - Unknown errors:
      - Input: `new Error("Something unexpected")` → category "unknown"
      - Input: `"string error"` → category "unknown", message is the string

    - All classified errors:
      - Are instanceof Context7Error
      - Are instanceof PDIError
      - Have the correct source property
      - Preserve the original error as cause

    **tests/unit/lib/cli-error-handler.test.ts:**
    Test the handleCommandError function. Since it calls `process.exit(1)`, we need to mock that.

    Setup:
    ```typescript
    import { spyOn } from "bun:test";
    // Mock process.exit to prevent test from actually exiting
    const mockExit = spyOn(process, "exit").mockImplementation(() => {
      throw new Error("process.exit called");
    });
    // Mock console.error to capture output
    const mockConsoleError = spyOn(console, "error").mockImplementation(() => {});
    ```

    Test cases:
    - ConfigError with validation issues:
      - Output includes "Config Error:"
      - Output includes validation issue details
      - Output includes fix hint

    - NotInitializedError:
      - Output includes "Error:" and "not initialized"
      - Output includes "pdi init" hint

    - Context7Error:
      - Output includes "Context7 Error:"
      - Output includes the hint

    - Generic PDIError:
      - Output includes "Error:" and message
      - Output includes hint if provided

    - Plain Error:
      - Output includes "Error:" and message
      - No hint line

    - Non-Error (string):
      - Output includes "Error:" and the string

    - PDI_DEBUG mode:
      - Set `process.env.PDI_DEBUG = "1"` before test
      - Output includes "Stack trace:"
      - Clean up env after test

    - All cases call process.exit(1)

    **Important:** Export `handleCommandError` from cli.ts for testing (or test it indirectly). If exporting from cli.ts is awkward (it has side effects from top-level `program.parse()`), consider extracting the function to a separate file like `src/lib/cli-utils.ts` or testing it by importing just the function. The simplest approach: export the function from cli.ts and in tests, only import the function (the top-level parse won't run since tests don't execute the module's side effects directly with bun:test).

    Actually, the cleanest approach: create `src/lib/error-handler.ts` that exports `handleCommandError`, and have cli.ts import from there. This avoids side-effect issues. However, to minimize file count, simply exporting from cli.ts works with bun:test since dynamic imports can be used.

    **Recommended:** Keep handleCommandError in cli.ts. For testing, extract it to a testable form. Since cli.ts has top-level await (`await loadApiKeyFromConfig()`), importing it in tests would trigger side effects. **Solution: Move handleCommandError to src/lib/error-handler.ts** and import it in cli.ts. This is a clean separation and avoids test complications.

    Update files_modified accordingly:
    - Create `src/lib/error-handler.ts` with `handleCommandError`
    - Import in `src/cli.ts`
    - Test from `tests/unit/lib/cli-error-handler.test.ts`
  </action>
  <verify>
    1. `bun test tests/unit/lib/context7-errors.test.ts` passes
    2. `bun test tests/unit/lib/cli-error-handler.test.ts` passes
    3. `bun test` (all tests) passes -- no regressions
    4. `bun run typecheck` passes
  </verify>
  <done>
    Test coverage complete for Phase 4 error handling: context7-errors.test.ts validates all 6 error categories (auth, network, rate_limit, redirect, not_found, unknown) with correct classification and message content. cli-error-handler.test.ts validates error output formatting for each error type (ConfigError with issues, NotInitializedError, Context7Error, generic Error, non-Error). PDI_DEBUG stack trace display also tested.
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun test` passes (all existing + new tests)
3. cli.ts has a single handleCommandError function (no duplicate try-catch patterns)
4. Context7 auth/network/rate_limit errors produce specific user messages
5. PDI_DEBUG=1 shows stack traces, normal mode does not
6. No raw stack traces leak in normal error output
7. "pdi auth" mentioned in Context7 auth error hints
8. "--offline" mentioned in Context7 network error hints
</verification>

<success_criteria>
- CLI error handler formats each error type differently (ConfigError shows fields, Context7Error shows category)
- Context7 errors are classified by category with specific actionable messages
- PDI_DEBUG environment variable controls stack trace visibility
- All 9 command action handlers use the unified error handler
- All tests pass including the new error handling tests
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-error-handling/04-02-SUMMARY.md`
</output>
