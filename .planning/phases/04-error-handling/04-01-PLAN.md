---
phase: 04-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/errors.ts
  - src/lib/config.ts
  - src/commands/init.ts
  - src/commands/add.ts
  - src/commands/sync.ts
  - src/commands/update.ts
  - src/commands/status.ts
  - src/commands/clean.ts
  - src/commands/generate.ts
  - src/commands/doctor.ts
  - src/index.ts
  - tests/unit/lib/errors.test.ts
  - tests/unit/lib/config-validation.test.ts
  - tests/unit/lib/config.test.ts
autonomous: true

must_haves:
  truths:
    - "PDIError, ConfigError, and Context7Error classes exist with code, hint, and cause properties"
    - "readConfig() on invalid JSON shows the parse error and suggests `pdi init --force` to regenerate"
    - "readConfig() on schema-invalid config shows which fields are wrong and what values are expected"
    - "All commands that check configExists() throw NotInitializedError instead of generic Error"
    - "All commands that check readConfig() === null throw ConfigError instead of generic Error"
    - "Error classes are exported from src/index.ts for programmatic API consumers"
  artifacts:
    - path: "src/lib/errors.ts"
      provides: "PDIError hierarchy with ConfigError and Context7Error"
      contains: "class PDIError"
    - path: "tests/unit/lib/errors.test.ts"
      provides: "Tests for error class construction, properties, and instanceof checks"
      contains: "PDIError"
    - path: "tests/unit/lib/config-validation.test.ts"
      provides: "Tests for config validation error formatting with various invalid configs"
      contains: "readConfig"
  key_links:
    - from: "src/lib/errors.ts"
      to: "src/lib/config.ts"
      via: "ConfigError thrown by readConfig()"
      pattern: "ConfigError"
    - from: "src/lib/errors.ts"
      to: "src/commands/*.ts"
      via: "commands import and throw PDIError subclasses"
      pattern: "NotInitializedError|ConfigError"
    - from: "src/lib/errors.ts"
      to: "src/index.ts"
      via: "error classes exported for programmatic API"
      pattern: "export.*PDIError"
---

<objective>
Create the structured error type hierarchy and enhance config validation to produce user-friendly error messages with actionable fix instructions.

Purpose: Provides the error infrastructure that Plan 04-02 (CLI error handler) builds on. Commands throw typed errors instead of generic `Error`, and config validation produces clear messages about what is wrong and how to fix it. This satisfies ERR-03 (config errors with fix instructions) and ERR-04 (Zod config validation -- already done, enhanced here).

Output: src/lib/errors.ts (error classes), enhanced config.ts validation, updated commands throwing typed errors, unit tests for error types and validation formatting.
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-error-handling/04-CONTEXT.md
@.planning/phases/04-error-handling/04-RESEARCH.md
@src/lib/config.ts
@src/lib/types.ts
@src/lib/context7-client.ts
@src/lib/constants.ts
@src/commands/init.ts
@src/commands/add.ts
@src/commands/sync.ts
@src/commands/update.ts
@src/commands/status.ts
@src/commands/clean.ts
@src/commands/generate.ts
@src/commands/doctor.ts
@src/commands/auth.ts
@src/index.ts
@package.json
@tests/helpers/factories.ts
@tests/helpers/mock-fs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error type hierarchy (src/lib/errors.ts)</name>
  <files>
    src/lib/errors.ts
    src/index.ts
  </files>
  <action>
    Create `src/lib/errors.ts` with the following error class hierarchy:

    **PDIError (base class):**
    - Extends `Error`
    - Constructor: `(message: string, options?: { code?: string; hint?: string; cause?: Error })`
    - Properties: `code: string` (default "PDI_ERROR"), `hint?: string`, `cause?: Error`
    - `name` property set to "PDIError"

    **ConfigError extends PDIError:**
    - Constructor: `(message: string, options?: { configPath?: string; validationIssues?: Array<{ path: string; message: string; expected?: string }>; hint?: string; cause?: Error })`
    - Properties: `configPath?: string`, `validationIssues?: Array<{ path: string; message: string; expected?: string }>`
    - `code` defaults to "CONFIG_INVALID"
    - `name` set to "ConfigError"
    - Method: `formatValidationIssues(): string` -- formats issues into readable multi-line output:
      ```
      - version: Expected string, got number
      - project.type: Expected "backend" | "frontend" | "fullstack" | "library" | "cli", got "unknown"
      ```

    **Context7Error extends PDIError:**
    - Constructor: `(message: string, options?: { category?: "auth" | "network" | "rate_limit" | "redirect" | "not_found" | "unknown"; source?: "http" | "mcp" | "none"; hint?: string; cause?: Error })`
    - Properties: `category: string` (default "unknown"), `source: string` (default "none")
    - `code` defaults to "CONTEXT7_ERROR"
    - `name` set to "Context7Error"

    **NotInitializedError extends PDIError:**
    - Constructor takes no arguments (or optional projectRoot for the hint)
    - Fixed message: "PDI not initialized in this project."
    - Fixed hint: "Run `pdi init` to initialize."
    - `code`: "NOT_INITIALIZED"
    - `name` set to "NotInitializedError"

    Export all classes and the validation issue type.

    **Update src/index.ts:**
    Add exports for the error classes at the end of the file:
    ```
    export { PDIError, ConfigError, Context7Error, NotInitializedError } from "./lib/errors.js";
    ```
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `grep "class PDIError" src/lib/errors.ts` finds the base class
    3. `grep "class ConfigError" src/lib/errors.ts` finds the subclass
    4. `grep "class Context7Error" src/lib/errors.ts` finds the subclass
    5. `grep "class NotInitializedError" src/lib/errors.ts` finds the subclass
    6. `grep "PDIError" src/index.ts` shows the export
  </verify>
  <done>
    Error hierarchy created: PDIError base with ConfigError (config path, validation issues, formatting), Context7Error (category, source), and NotInitializedError (fixed message/hint). All classes exported from src/index.ts for programmatic API consumers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance config validation with fix instructions</name>
  <files>
    src/lib/config.ts
  </files>
  <action>
    Enhance the `readConfig()` function in `src/lib/config.ts` to throw `ConfigError` with user-friendly messages and fix instructions.

    **Current behavior (readConfig lines 91-118):**
    - Missing config: returns `null`
    - Valid config: returns parsed data
    - Zod validation failure: throws `Error("Invalid config: path1: msg1; path2: msg2")`
    - JSON parse failure: throws `Error("Failed to read config: ...")`

    **New behavior:**
    - Missing config: returns `null` (unchanged -- callers handle this)
    - Valid config: returns parsed data (unchanged)
    - Zod validation failure: throw `ConfigError` with:
      - message: "Config validation failed"
      - configPath: the resolved config file path
      - validationIssues: mapped from `result.error.issues` with path, message, and expected type
      - hint: `"Fix the fields above in ${configPath}, or run \`pdi init --force\` to regenerate."`
    - JSON parse failure (SyntaxError): throw `ConfigError` with:
      - message: "Config file contains invalid JSON"
      - configPath: the resolved config file path
      - hint: `"Check ${configPath} for syntax errors (missing commas, brackets, quotes), or run \`pdi init --force\` to regenerate."`
      - cause: the original SyntaxError
    - Other read errors (permission, etc.): throw `ConfigError` with:
      - message: "Failed to read config file"
      - configPath
      - hint: `"Check file permissions for ${configPath}"`
      - cause: the original error

    **Implementation:**
    Import `ConfigError` from `./errors.js`. Modify the try-catch in `readConfig()`:

    ```typescript
    try {
      const content = await readFile(configPath, "utf-8");
      let parsed: unknown;
      try {
        parsed = JSON.parse(content);
      } catch (parseError) {
        throw new ConfigError("Config file contains invalid JSON", {
          configPath,
          hint: `Check ${configPath} for syntax errors (missing commas, brackets, quotes), or run \`pdi init --force\` to regenerate.`,
          cause: parseError instanceof Error ? parseError : undefined,
        });
      }
      const result = PDIConfigSchema.safeParse(parsed);
      if (!result.success) {
        const issues = result.error.issues.map((i) => ({
          path: i.path.join("."),
          message: i.message,
          expected: "expected" in i ? String(i.expected) : undefined,
        }));
        throw new ConfigError("Config validation failed", {
          configPath,
          validationIssues: issues,
          hint: `Fix the fields above in ${configPath}, or run \`pdi init --force\` to regenerate.`,
        });
      }
      return result.data as PDIConfig;
    } catch (error) {
      if (error instanceof ConfigError) {
        throw error; // Re-throw our typed errors
      }
      throw new ConfigError("Failed to read config file", {
        configPath,
        hint: `Check file permissions for ${configPath}.`,
        cause: error instanceof Error ? error : undefined,
      });
    }
    ```

    Also update `readPackageJson()` to throw more descriptive errors:
    - JSON parse failure: include path and suggest checking file

    **IMPORTANT: Update existing tests in tests/unit/lib/config.test.ts:**
    The existing config tests check for old error messages that will change:
    - Line 129-131: `toThrow("Failed to read config")` → update to `toThrow("invalid JSON")` and check `toBeInstanceOf(ConfigError)`
    - Line 139: `toThrow("Invalid config")` → update to `toThrow("Config validation failed")` and check `toBeInstanceOf(ConfigError)`
    - Line 161: `toThrow("Invalid config")` → same update as above
    Add `import { ConfigError } from "../../../src/lib/errors.js"` to the test file.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `grep "ConfigError" src/lib/config.ts` shows the import and usage
    3. `grep "validationIssues" src/lib/config.ts` shows the issue mapping
    4. `grep "pdi init --force" src/lib/config.ts` shows the fix hint
  </verify>
  <done>
    Config validation enhanced: readConfig() throws ConfigError with configPath, field-level validation issues, and fix instructions for JSON syntax errors, schema validation failures, and permission errors. readPackageJson() also improved with descriptive error messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update commands to throw typed errors</name>
  <files>
    src/commands/init.ts
    src/commands/add.ts
    src/commands/sync.ts
    src/commands/update.ts
    src/commands/status.ts
    src/commands/clean.ts
    src/commands/generate.ts
    src/commands/doctor.ts
  </files>
  <action>
    Update all command files to use typed error classes instead of generic `new Error()`.

    **Pattern to replace across all commands:**

    Replace `throw new Error("PDI not initialized. Run: pdi init")` with:
    ```typescript
    import { NotInitializedError } from "../lib/errors.js";
    throw new NotInitializedError();
    ```
    This applies to: add.ts, sync.ts, update.ts, status.ts, clean.ts (all check `configExists()`).

    Replace `throw new Error("Failed to read config")` with:
    ```typescript
    import { ConfigError } from "../lib/errors.js";
    throw new ConfigError("Config file exists but returned null", {
      hint: "Run `pdi init --force` to regenerate config.",
    });
    ```
    This applies to: add.ts, sync.ts, update.ts, status.ts, clean.ts (all check `readConfig() === null`).

    Replace `throw new Error("No package.json found")` in sync.ts with:
    ```typescript
    import { PDIError } from "../lib/errors.js";
    throw new PDIError("No package.json found", {
      code: "NO_PACKAGE_JSON",
      hint: "Run this command in a Node.js project directory with a package.json file.",
    });
    ```

    **For each file**, add the import at the top:
    ```typescript
    import { NotInitializedError, ConfigError } from "../lib/errors.js";
    ```
    (or PDIError as needed)

    **Important:** Do NOT change any other behavior in the commands. Only replace the error throws. The `readConfig()` function in config.ts now throws `ConfigError` on invalid configs, so the `config === null` case is truly "file exists but is empty or returns null unexpectedly."

    **doctor.ts special case:** Doctor already handles config read errors gracefully (catches and shows diagnostic). Don't change its error handling -- it's designed to diagnose issues, not crash.

    **generate.ts:** Check if it has initialization guards and update them if present.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `grep "NotInitializedError" src/commands/add.ts` finds the import and usage
    3. `grep "new Error" src/commands/add.ts src/commands/sync.ts src/commands/update.ts src/commands/status.ts src/commands/clean.ts` shows no more generic Error throws for config/init checks
    4. `bun test` passes (existing tests still work -- commands still throw, just typed errors now)
  </verify>
  <done>
    All commands updated to throw typed errors: NotInitializedError for missing initialization, ConfigError for null config reads, PDIError for missing package.json. Doctor command left unchanged (diagnostic tool that handles errors gracefully). All existing behavior preserved -- only error types changed.
  </done>
</task>

<task type="auto">
  <name>Task 4: Tests for error types and config validation</name>
  <files>
    tests/unit/lib/errors.test.ts
    tests/unit/lib/config-validation.test.ts
  </files>
  <action>
    Create comprehensive unit tests for the error infrastructure.

    **tests/unit/lib/errors.test.ts:**
    Test the error class hierarchy:

    - `PDIError`:
      - Creates with message only (defaults: code="PDI_ERROR", no hint, no cause)
      - Creates with all options (code, hint, cause)
      - Is instanceof Error
      - Has name "PDIError"
      - cause preserves original error

    - `ConfigError`:
      - Creates with message only (defaults: code="CONFIG_INVALID")
      - Creates with configPath and validationIssues
      - Is instanceof PDIError (inheritance)
      - Is instanceof ConfigError
      - Has name "ConfigError"
      - `formatValidationIssues()` returns readable multi-line string
      - `formatValidationIssues()` handles empty issues (returns empty string)
      - `formatValidationIssues()` includes expected values when present

    - `Context7Error`:
      - Creates with defaults (category="unknown", source="none")
      - Creates with specific category and source
      - Is instanceof PDIError (inheritance)
      - Has name "Context7Error"

    - `NotInitializedError`:
      - Has fixed message and hint
      - Is instanceof PDIError
      - Has code "NOT_INITIALIZED"

    **tests/unit/lib/config-validation.test.ts:**
    Test config validation error formatting using mock filesystem:

    - readConfig with corrupted JSON (syntax error):
      - Throws ConfigError
      - Error message mentions "invalid JSON"
      - Error has configPath set
      - Error hint mentions `pdi init --force`

    - readConfig with schema-invalid config (wrong types):
      - `{ version: 123 }` → ConfigError with validationIssues showing "version: Expected string"
      - `{ project: { type: "invalid" } }` → ConfigError showing expected enum values
      - Missing required fields → ConfigError listing them

    - readConfig with completely empty object `{}`:
      - Throws ConfigError with multiple validation issues

    - readConfig with valid config (happy path):
      - Returns PDIConfig object (no error)
      - Existing test coverage should already cover this

    Use the existing mock-fs helpers from tests/helpers/mock-fs.ts. Import factories from tests/helpers/factories.ts for creating valid configs to compare against.
  </action>
  <verify>
    1. `bun test tests/unit/lib/errors.test.ts` passes
    2. `bun test tests/unit/lib/config-validation.test.ts` passes
    3. `bun test` (all tests) passes -- no regressions
    4. `bun run typecheck` passes
  </verify>
  <done>
    Test coverage complete for error infrastructure: errors.test.ts validates the entire class hierarchy (construction, properties, instanceof, formatting), config-validation.test.ts validates error output for corrupted JSON, schema-invalid configs, and various field type mismatches. All tests pass alongside existing test suite.
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun test` passes (all existing + new tests)
3. src/lib/errors.ts exports PDIError, ConfigError, Context7Error, NotInitializedError
4. src/index.ts re-exports error classes
5. All commands (except doctor) throw typed errors for init/config checks
6. readConfig() throws ConfigError with validation issues and fix hints
7. No raw `new Error("PDI not initialized...")` remains in command files
</verification>

<success_criteria>
- Error classes are usable: `new ConfigError("msg", { configPath, validationIssues, hint })` works
- Config validation produces field-level error messages with fix instructions
- Commands throw typed errors (NotInitializedError, ConfigError) instead of generic Error
- All tests pass including new error and validation tests
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-error-handling/04-01-SUMMARY.md`
</output>
