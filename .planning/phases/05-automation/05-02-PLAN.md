---
phase: 05-automation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/commands/status.ts
  - src/cli.ts
  - src/lib/postinstall.ts
  - src/index.ts
  - package.json
  - tests/unit/commands/status.test.ts
  - tests/unit/lib/postinstall.test.ts
autonomous: true

must_haves:
  truths:
    - "pdi status --check exits with non-zero code when docs are stale, missing, or orphaned"
    - "pdi status --check exits with code 0 when all docs are fresh"
    - "pdi status --format=json outputs structured JSON with issues and summary"
    - "pdi status (without --check) displays a human-readable table showing freshness per framework"
    - "Postinstall script writes to stderr and never exits non-zero"
    - "Postinstall shows discovery hint when no PDI config exists"
    - "Postinstall shows stale framework details when staleness is detected"
    - "Postinstall uses ANSI codes directly, not chalk, for minimal import overhead"
  artifacts:
    - path: "src/commands/status.ts"
      provides: "Enhanced status command with --check and --format flags and freshness table"
      exports: ["statusCommand"]
    - path: "src/lib/postinstall.ts"
      provides: "Postinstall entry point that writes freshness hints to stderr"
      exports: ["runPostinstall"]
    - path: "src/cli.ts"
      provides: "Updated Commander setup with --check and --format options on status command"
    - path: "src/index.ts"
      provides: "Exports for registry-client, freshness, and postinstall modules"
    - path: "package.json"
      provides: "postinstall script entry and build:postinstall script"
  key_links:
    - from: "src/commands/status.ts"
      to: "src/lib/freshness.ts"
      via: "import checkFreshness, EXIT_CODES"
      pattern: "import.*checkFreshness.*from.*freshness"
    - from: "src/commands/status.ts"
      to: "src/lib/registry-client.ts"
      via: "indirect through freshness.ts"
    - from: "src/lib/postinstall.ts"
      to: "src/lib/config.ts"
      via: "import configExists, readConfig"
      pattern: "import.*configExists.*from.*config"
    - from: "src/lib/postinstall.ts"
      to: "src/lib/freshness.ts"
      via: "import checkFreshness"
      pattern: "import.*checkFreshness.*from.*freshness"
    - from: "src/cli.ts"
      to: "src/commands/status.ts"
      via: "status command options --check --format"
    - from: "package.json"
      to: "dist/postinstall.js"
      via: "scripts.postinstall"
      pattern: "\"postinstall\".*dist/postinstall"
---

<objective>
Integrate freshness checking into the CLI: enhance `pdi status` with --check and --format flags for CI usage, create the postinstall hook for npm/bun install notifications, and wire everything together.

Purpose: This transforms the raw freshness logic (from plan 05-01) into user-facing features. The `--check` flag makes PDI usable as a CI gate. The postinstall hook provides passive notifications to developers after installing dependencies.

Output: A fully functional `pdi status --check` command with exit codes and JSON output, plus a postinstall script that writes staleness hints to stderr.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-automation/05-RESEARCH.md
@.planning/phases/05-automation/05-01-SUMMARY.md
@src/commands/status.ts
@src/cli.ts
@src/lib/error-handler.ts
@src/lib/errors.ts
@src/lib/config.ts
@src/lib/types.ts
@src/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance status command with --check and --format flags</name>
  <files>
    src/commands/status.ts
    src/cli.ts
    tests/unit/commands/status.test.ts
  </files>
  <action>
**Enhance `src/commands/status.ts`:**

Update the `statusCommand` function signature to accept new options:
```typescript
interface StatusCommandOptions {
  projectRoot?: string;
  check?: boolean;
  format?: "table" | "json";
}
```

Add freshness checking logic AFTER the existing status display:

1. Import `checkFreshness`, `EXIT_CODES`, `FreshnessCheckOutput` from `../lib/freshness.js`
2. Import `readPackageJson` (already imported)
3. Call `checkFreshness(config, packageJson)` to get freshness results
4. **Table output (default `--format=table`):**
   - Print a "Freshness Check" section with a formatted table
   - Columns: Framework, Indexed, Latest, Status
   - Use chalk for coloring: green for up-to-date, yellow for stale, red for missing/orphaned
   - Use padEnd() for column alignment (no cli-table3 dependency)
   - Show summary line: "X up-to-date, Y stale, Z missing, W orphaned"
5. **JSON output (`--format=json`):**
   - Output the `StatusCheckResult` JSON structure to stdout (per research pattern)
   - Include: project name, timestamp, status ("ok" | "issues_found"), exitCode, issues array, summary
   - Use `JSON.stringify(result, null, 2)` for readable output
6. **--check flag behavior:**
   - When `--check` is set AND there are issues: call `process.exit(exitCode)` with the appropriate exit code from `FreshnessCheckOutput`
   - When `--check` is set AND no issues: exit normally (code 0)
   - When `--check` is NOT set: show freshness info but do NOT exit with non-zero (existing behavior)
   - Handle network errors: catch errors from checkFreshness, use EXIT_CODES.NETWORK_ERROR (5)

**Update `src/cli.ts`:**

Update the status command registration to accept new options:
```typescript
program
  .command("status")
  .description("Show current PDI status and doc freshness")
  .option("--check", "Exit with non-zero code if issues found (for CI)")
  .option("--format <format>", "Output format: table or json", "table")
  .action(async (options) => {
    try {
      await statusCommand(options);
    } catch (error) {
      handleCommandError(error);
    }
  });
```

**Write tests `tests/unit/commands/status.test.ts`:**

Mock: config.ts (configExists, readConfig, readPackageJson, detectDependencies, getMajorVersion), fs-utils.ts, index-parser.ts, index-utils.ts, freshness.ts (checkFreshness).

Test cases:
- `--check` with all fresh -> exits normally (no process.exit call)
- `--check` with stale docs -> calls process.exit(1)
- `--check` with missing docs -> calls process.exit(2)
- `--check` with orphaned docs -> calls process.exit(3)
- `--check` with mixed issues -> calls process.exit(4)
- `--check` with network error -> calls process.exit(5)
- `--format=json` outputs valid JSON to stdout with correct structure
- `--format=json` includes project, timestamp, status, exitCode, issues, summary fields
- Without `--check` flag, freshness issues are shown but process does NOT exit with non-zero
- Without options, status command still works as before (backward compatible)

**Important per locked decisions:**
- Exit codes must be differentiated: 1=stale, 2=missing, 3=orphaned, 4=mixed, 5=network
- `--format=json` for tool integration
- Orphaned frameworks cause non-zero exit in --check mode
- Network errors fail with clear error (no silent pass)
  </action>
  <verify>
```bash
bun test tests/unit/commands/status.test.ts
bunx tsc --noEmit
```
All status command tests pass and types check.
  </verify>
  <done>
- `pdi status --check` exits with differentiated exit codes (0-5) based on doc health
- `pdi status --format=json` outputs structured JSON for CI tools
- `pdi status` (no flags) shows freshness table without exiting non-zero
- Backward compatible with existing status display
  </done>
</task>

<task type="auto">
  <name>Task 2: Postinstall hook, build config, and exports</name>
  <files>
    src/lib/postinstall.ts
    tests/unit/lib/postinstall.test.ts
    src/index.ts
    package.json
  </files>
  <action>
**Create `src/lib/postinstall.ts`:**

A lightweight script that checks for PDI config and reports staleness to stderr. Must follow these rules per research and locked decisions:
- Write ALL output to `process.stderr.write()` (npm 7+ suppresses dependency stdout)
- Use ANSI escape codes directly (NOT chalk import) for minimal import overhead
- NEVER exit non-zero (would break npm install)
- Wrap entire execution in try-catch that silently exits 0
- Use dynamic imports to lazy-load heavy modules only if needed
- Set a total execution timeout of 5 seconds

```typescript
// ANSI codes (no chalk import for speed)
const RESET = "\x1b[0m";
const CYAN = "\x1b[36m";
const YELLOW = "\x1b[33m";
const DIM = "\x1b[2m";
const GREEN = "\x1b[32m";

export async function runPostinstall(): Promise<void> {
  try {
    const projectRoot = process.cwd();

    // Dynamic import to minimize cold-start time
    const { configExists } = await import("./config.js");

    if (!configExists(projectRoot)) {
      // Discovery hint per locked decision: always show something
      process.stderr.write(
        `\n${CYAN}[pdi]${RESET} Run \`npx pdi init\` to set up documentation indexing\n\n`
      );
      return;
    }

    // PDI is configured - run freshness check
    const { readConfig, readPackageJson } = await import("./config.js");
    const { checkFreshness } = await import("./freshness.js");

    const config = await readConfig(projectRoot);
    if (!config) return;

    const packageJson = await readPackageJson(projectRoot);

    // Use AbortController for total timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);

    try {
      const result = await checkFreshness(config, packageJson);
      clearTimeout(timeout);

      if (result.exitCode === 0) {
        // All fresh - show brief confirmation
        process.stderr.write(
          `\n${GREEN}[pdi]${RESET} All documentation is up-to-date\n\n`
        );
        return;
      }

      // Per locked decision: detailed list format with version transitions
      const staleItems = result.results
        .filter(r => r.status === "stale")
        .map(r => `${r.framework} (v${r.indexedVersion}→v${r.latestVersion})`);

      const orphanedItems = result.results
        .filter(r => r.status === "orphaned")
        .map(r => r.framework);

      const missingItems = result.results
        .filter(r => r.status === "missing")
        .map(r => r.framework);

      let message = `\n${YELLOW}[pdi]${RESET} Doc issues detected:\n`;

      if (staleItems.length > 0) {
        message += `${DIM}  Stale: ${staleItems.join(", ")}${RESET}\n`;
      }
      if (orphanedItems.length > 0) {
        message += `${DIM}  Orphaned: ${orphanedItems.join(", ")}${RESET}\n`;
      }
      if (missingItems.length > 0) {
        message += `${DIM}  Missing: ${missingItems.join(", ")}${RESET}\n`;
      }

      message += `${DIM}  Run \`npx pdi sync\` to update${RESET}\n\n`;
      process.stderr.write(message);
    } catch {
      clearTimeout(timeout);
      // Network error or timeout - silently ignore
    }
  } catch {
    // NEVER fail - postinstall errors break npm install
  }
}

// Entry point when run directly
runPostinstall();
```

**Write tests `tests/unit/lib/postinstall.test.ts`:**

Mock: config.ts (configExists, readConfig, readPackageJson), freshness.ts (checkFreshness), process.stderr.write, process.cwd.

Test cases:
- When no PDI config exists: writes discovery hint to stderr containing "pdi init"
- When config exists and all fresh: writes "up-to-date" message to stderr
- When config exists with stale docs: writes framework names with version transitions to stderr
- When config exists with orphaned docs: writes orphaned framework names to stderr
- When config exists with missing docs: writes missing framework names to stderr
- Never calls process.exit (verify no process.exit calls)
- When readConfig throws: silently catches error, writes nothing, does not throw
- When checkFreshness throws (network error): silently catches, does not throw
- All output goes to stderr (process.stderr.write), never stdout (console.log)

**Update `package.json`:**

1. Add postinstall script: `"postinstall": "node ./dist/postinstall.js"`
2. Add build:postinstall to build:js script: update build:js to ALSO build `src/lib/postinstall.ts` -> `dist/postinstall.js`:
   ```
   "build:js": "bun build src/cli.ts --outfile dist/cli.js --target node --format esm && bun build src/index.ts --outfile dist/index.js --target node --format esm && bun build src/lib/postinstall.ts --outfile dist/postinstall.js --target node --format esm"
   ```
3. Add `"dist/postinstall.js"` is already covered by `"files": ["dist"]` so no change needed there.

**Update `src/index.ts`:**

Add exports for the new modules:
```typescript
// Registry Client
export {
  fetchLatestVersion,
  fetchLatestVersions,
  NPM_REGISTRY_URL,
} from "./lib/registry-client.js";

// Freshness
export {
  checkVersionFreshness,
  checkFreshness,
  EXIT_CODES,
} from "./lib/freshness.js";
export type {
  ExitCode,
  FreshnessStatus,
  FreshnessResult,
  FreshnessCheckOutput,
} from "./lib/freshness.js";

// Postinstall
export { runPostinstall } from "./lib/postinstall.js";
```

**Important per locked decisions:**
- Postinstall always shows something: discovery hint (no config) or freshness details (with config)
- Detailed list format with version transitions (e.g., `react (v18.2→v19.0)`)
- Smart check: runs freshness logic, only shows message if real issues
- Use npx/bunx approach: postinstall uses `node ./dist/postinstall.js` directly (since it's the package's own postinstall, node can run the bundled file directly)
- stderr for all output (npm 7+ suppresses dependency stdout)
- ANSI codes directly, no chalk import
- Document Bun trustedDependencies limitation (not in code, but in the summary)
  </action>
  <verify>
```bash
bun test tests/unit/lib/postinstall.test.ts
bunx tsc --noEmit
bunx ultracite check

# Verify build works with new postinstall entry point
bun run build

# Verify postinstall.js is in dist/
ls -la dist/postinstall.js

# Full test suite
bun test
```
  </verify>
  <done>
- postinstall.ts writes freshness hints to stderr, never exits non-zero, handles all errors silently
- package.json has postinstall script pointing to dist/postinstall.js
- build:js updated to also bundle postinstall.ts
- src/index.ts exports all new modules (registry-client, freshness, postinstall)
- All tests pass including new postinstall tests
- Build produces dist/postinstall.js alongside dist/cli.js and dist/index.js
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
bun test

# Type checking
bunx tsc --noEmit

# Lint
bunx ultracite check

# Build works and produces postinstall.js
bun run build && ls dist/postinstall.js

# Verify --check flag works (manual smoke test)
bun run src/cli.ts status --check; echo "Exit code: $?"

# Verify --format=json works
bun run src/cli.ts status --format=json | head -20

# Verify exit codes are correct
# (in a project with stale docs, --check should exit non-zero)
```
</verification>

<success_criteria>
1. `pdi status --check` exits with correct differentiated exit codes (0=ok, 1=stale, 2=missing, 3=orphaned, 4=mixed, 5=network)
2. `pdi status --format=json` outputs structured JSON with project, timestamp, status, exitCode, issues, summary
3. `pdi status` (no flags) shows freshness table but does NOT exit non-zero
4. Postinstall writes to stderr, never exits non-zero, shows discovery hint or staleness details
5. dist/postinstall.js is built and included in package
6. All new and existing tests pass
7. No lint or type errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-automation/05-02-SUMMARY.md`
</output>
