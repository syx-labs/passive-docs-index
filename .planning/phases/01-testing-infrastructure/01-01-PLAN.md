---
phase: 01-testing-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bunfig.toml
  - tests/helpers/setup.ts
  - tests/helpers/factories.ts
  - tests/helpers/mock-fetch.ts
  - tests/helpers/mock-fs.ts
  - tests/helpers/mock-mcp.ts
  - tests/fixtures/config/valid-config.json
  - tests/fixtures/config/minimal-config.json
  - tests/fixtures/context7/search-library.json
  - tests/fixtures/context7/query-docs.json
  - tests/fixtures/context7/error-response.json
  - tests/fixtures/package-json/cli-project.json
  - tests/fixtures/package-json/frontend-project.json
  - tests/fixtures/package-json/fullstack-project.json
  - tests/fixtures/claude-md/with-index.md
  - tests/fixtures/claude-md/without-index.md
  - tests/fixtures/mcp/query-result.json
  - tests/coverage-loader.test.ts
  - scripts/check-coverage.ts
  - src/lib/mcp-client.ts
  - src/lib/context7-client.ts
  - src/lib/config.ts
  - src/lib/context7.ts
  - src/lib/generate.ts
  - src/lib/interfaces/mcp-client.ts
  - src/commands/init.ts
  - src/commands/add.ts
  - src/commands/sync.ts
  - src/commands/status.ts
  - src/commands/clean.ts
  - src/commands/update.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running `bun test` discovers and runs test files from tests/ directory"
    - "All src/lib/ modules appear in coverage output (no invisible modules)"
    - "Silent exception swallowing is replaced with console.error + propagation in all 6 identified locations"
    - "IMcpClient interface exists and production code uses it instead of direct mcp-client functions"
    - "CLI commands accept optional projectRoot parameter (default process.cwd())"
    - "Per-module coverage script parses lcov and enforces 80% threshold per module"
  artifacts:
    - path: "bunfig.toml"
      provides: "Bun test configuration with coverage"
      contains: "[test]"
    - path: "tests/helpers/setup.ts"
      provides: "Global test setup with state reset"
      contains: "resetClients"
    - path: "tests/helpers/mock-fetch.ts"
      provides: "Fetch interception helper"
      contains: "createFetchMock"
    - path: "tests/helpers/mock-fs.ts"
      provides: "Filesystem mock helpers"
      contains: "mock.module"
    - path: "tests/helpers/mock-mcp.ts"
      provides: "FakeMcpClient implementation"
      contains: "FakeMcpClient"
    - path: "tests/helpers/factories.ts"
      provides: "Factory functions for test data"
      contains: "createConfig"
    - path: "scripts/check-coverage.ts"
      provides: "Per-module coverage enforcement"
      contains: "parseLcov"
    - path: "tests/coverage-loader.test.ts"
      provides: "Force-imports all src/lib modules for coverage"
      contains: "Bun.Glob"
    - path: "src/lib/interfaces/mcp-client.ts"
      provides: "IMcpClient interface and FakeMcpClient"
      exports: ["IMcpClient", "McpCliClient", "FakeMcpClient"]
  key_links:
    - from: "bunfig.toml"
      to: "tests/helpers/setup.ts"
      via: "preload config"
      pattern: "preload.*setup"
    - from: "tests/helpers/setup.ts"
      to: "src/lib/context7-client.ts"
      via: "resetClients import"
      pattern: "resetClients"
    - from: "scripts/check-coverage.ts"
      to: "coverage/lcov.info"
      via: "lcov file parsing"
      pattern: "lcov\\.info"
    - from: "src/lib/interfaces/mcp-client.ts"
      to: "src/lib/mcp-client.ts"
      via: "McpCliClient wraps existing functions"
      pattern: "isMcpCliAvailable|queryContext7|resolveContext7Library"
---

<objective>
Set up the complete test infrastructure and refactor the existing codebase for testability.

Purpose: Creates the foundation that all subsequent test plans depend on -- without this infrastructure, no tests can be written. The testability refactoring fixes silent exception swallowing, extracts the MCP client interface, and adds projectRoot parameters to commands.

Output: bunfig.toml, tests/helpers/*, tests/fixtures/*, scripts/check-coverage.ts, coverage-loader.test.ts, IMcpClient interface, and refactored src/ modules.
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-CONTEXT.md
@.planning/phases/01-testing-infrastructure/01-RESEARCH.md
@src/lib/config.ts
@src/lib/context7-client.ts
@src/lib/mcp-client.ts
@src/lib/context7.ts
@src/lib/fs-utils.ts
@src/lib/index-parser.ts
@src/lib/templates.ts
@src/lib/types.ts
@src/lib/index-utils.ts
@src/lib/constants.ts
@src/commands/init.ts
@src/commands/add.ts
@src/commands/sync.ts
@src/commands/status.ts
@src/commands/clean.ts
@src/commands/update.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure (bunfig, helpers, fixtures, scripts)</name>
  <files>
    bunfig.toml
    tests/helpers/setup.ts
    tests/helpers/factories.ts
    tests/helpers/mock-fetch.ts
    tests/helpers/mock-fs.ts
    tests/helpers/mock-mcp.ts
    tests/fixtures/config/valid-config.json
    tests/fixtures/config/minimal-config.json
    tests/fixtures/context7/search-library.json
    tests/fixtures/context7/query-docs.json
    tests/fixtures/context7/error-response.json
    tests/fixtures/package-json/cli-project.json
    tests/fixtures/package-json/frontend-project.json
    tests/fixtures/package-json/fullstack-project.json
    tests/fixtures/claude-md/with-index.md
    tests/fixtures/claude-md/without-index.md
    tests/fixtures/mcp/query-result.json
    tests/coverage-loader.test.ts
    scripts/check-coverage.ts
    package.json
  </files>
  <action>
    Create the complete test infrastructure following the architecture in RESEARCH.md.

    **bunfig.toml:**
    Configure bun test with preload = ["./tests/helpers/setup.ts"], coverage = true, coverageReporter = ["text", "lcov"], coverageDir = "./coverage", coverageThreshold = 0.8, coverageSkipTestFiles = true, coveragePathIgnorePatterns for tests/, dist/, scripts/, *.config.*

    **tests/helpers/setup.ts:**
    Global test setup that imports beforeEach/afterEach from bun:test. In beforeEach: call resetClients() from src/lib/context7-client.ts and resetMcpCliCache() from src/lib/mcp-client.ts. This ensures no cached state leaks between tests.

    **tests/helpers/mock-fetch.ts:**
    Create the createFetchMock(routes: FetchRoute[]) helper as specified in RESEARCH.md. It uses spyOn(global, 'fetch') to intercept fetch calls, match against route patterns (string or RegExp), validate methods, and return mock responses. Unmatched fetches throw an error (fail loudly). Per user decision: validates URLs and payloads, not just return values.

    **tests/helpers/mock-fs.ts:**
    Create helper functions for filesystem mocking. Provide a `createMockFs(files: Record<string, string>)` function that returns a Map and the mock implementations for existsSync, readFile, writeFile, mkdir, readdir, rm, stat. Callers will use these with `mock.module("node:fs")` and `mock.module("node:fs/promises")`. Include clear documentation that mock.module() MUST be called before importing tested modules.

    **tests/helpers/mock-mcp.ts:**
    Create the FakeMcpClient that implements IMcpClient (will be created in Task 2). Provide setAvailable(), setResponse() methods for test configuration. Also export a helper to mock the prompts library: `createPromptsMock(responses: Record<string, unknown>)`.

    **tests/helpers/factories.ts:**
    Create factory functions: createConfig(overrides), createPackageJson(overrides), createFrameworkConfig(overrides), createIndexSection(overrides), createDocFile(overrides). Each returns a valid object with sensible defaults that can be overridden. Import types from src/lib/types.ts.

    **tests/fixtures/ directory:**
    Create real fixture files (not minimal invented objects -- per user decision):
    - config/valid-config.json: Full PDIConfig with 2 frameworks (hono, drizzle), internal enabled
    - config/minimal-config.json: Minimal valid config with just project and empty frameworks
    - context7/search-library.json: Captured Context7 search response array with id, name, description fields
    - context7/query-docs.json: Captured Context7 query response with content blocks (title, content, source)
    - context7/error-response.json: Error response with library_redirected message
    - package-json/cli-project.json: package.json with bin field and CLI deps
    - package-json/frontend-project.json: package.json with react, vite deps
    - package-json/fullstack-project.json: package.json with hono + react deps
    - claude-md/with-index.md: CLAUDE.md containing pdi:begin/pdi:end markers with sample index
    - claude-md/without-index.md: CLAUDE.md without any PDI markers
    - mcp/query-result.json: Captured MCP CLI output (JSON with content blocks)

    **tests/coverage-loader.test.ts:**
    Create the coverage loader that uses Bun.Glob("src/lib/**/*.ts") to dynamically import all source modules, ensuring they appear in coverage reports. Skip .d.ts files.

    **scripts/check-coverage.ts:**
    Create the per-module coverage enforcement script as specified in RESEARCH.md. Parse coverage/lcov.info, compute line and function coverage per module (config, templates, index-parser, fs-utils, context7, context7-client, mcp-client, index-utils). Exit 1 if any module is below 80%. Note: branch coverage is NOT supported by Bun (GitHub #7100) -- enforce lines + functions only, per research findings.

    **package.json updates:**
    Update the "test" script to: "bun test --coverage && bun run scripts/check-coverage.ts"
  </action>
  <verify>
    1. `bun test --coverage` runs without errors (coverage-loader.test.ts should pass)
    2. `ls tests/helpers/` shows setup.ts, factories.ts, mock-fetch.ts, mock-fs.ts, mock-mcp.ts
    3. `ls tests/fixtures/` shows config/, context7/, package-json/, claude-md/, mcp/ directories with files
    4. `cat bunfig.toml` shows [test] section with preload and coverage config
    5. `bun run scripts/check-coverage.ts` runs (may warn about low coverage -- expected before tests are written)
    6. TypeScript compiles: `bun run typecheck` passes
  </verify>
  <done>
    Test infrastructure is complete: bunfig.toml configures bun:test with coverage, helpers provide reusable mock utilities (fetch, fs, mcp, prompts), fixtures contain realistic test data, coverage-loader ensures all modules appear in reports, and check-coverage.ts enforces per-module thresholds. The `bun test` script chain works end-to-end.
  </done>
</task>

<task type="auto">
  <name>Task 2: Testability refactoring of source modules</name>
  <files>
    src/lib/interfaces/mcp-client.ts
    src/lib/mcp-client.ts
    src/lib/context7-client.ts
    src/lib/context7.ts
    src/lib/config.ts
    src/lib/generate.ts
    src/commands/init.ts
    src/commands/add.ts
    src/commands/sync.ts
    src/commands/status.ts
    src/commands/clean.ts
    src/commands/update.ts
  </files>
  <action>
    Refactor the codebase for testability following the locked decisions in CONTEXT.md. This is DEEP refactoring: extract abstraction layers that improve testability AND prepare for future phases.

    **1. IMcpClient Interface (src/lib/interfaces/mcp-client.ts):**
    Create a clean interface following the pattern in RESEARCH.md:
    ```
    export interface IMcpClient {
      isAvailable(): Promise<boolean>;
      queryDocs(libraryId: string, query: string): Promise<McpResult>;
      resolveLibrary(libraryName: string): Promise<McpResult>;
    }
    ```
    Create McpCliClient class that wraps existing mcp-client.ts functions (isMcpCliAvailable, queryContext7, resolveContext7Library). Create FakeMcpClient class for testing.
    Export McpResult interface (reuse MCPResult from mcp-client.ts).

    This interface should be designed for Phase 4 (Error Handling) and Phase 6 (Claude Code Skills) to build on -- not a throwaway test seam.

    **2. Fix Silent Exception Swallowing (6 locations):**
    Add console.error before each silent catch. Do NOT implement full error handling (that's Phase 4). Minimal structured logging.

    - config.ts:117-119 (readPackageJson): Add `console.error("Failed to read package.json:", error)` before `return null`
    - context7-client.ts:61-64 (getHttpClient): Add `console.error("Failed to create Context7 HTTP client:", error)` before nulling
    - context7-client.ts:133-135 (resolveLibraryId): Add `console.error("Failed to resolve library ID:", libraryId, error)` before `return null`
    - context7-client.ts:363-365 (searchLibrary): Add `console.error("Failed to search library:", libraryName, error)` before `return null`
    - mcp-client.ts:70-73 (findInPath): Add `console.error("Failed to find", executable, "in PATH:", error)` -- but keep this as debug-level since it's expected to fail for some paths. Use a light approach: only log if verbose/debug mode would be enabled, or just add a comment noting Phase 4 will handle this properly. Actually, per CONTEXT.md: "log errors before propagating them -- immediate visibility". So add console.error for all except findInPath (which is normal control flow, not an error).
    - generate.ts:289 (scanProjectFiles readdir): Add `console.error("Failed to scan directory:", error)` before continuing

    For findInPath specifically: this is expected to fail (checking PATH locations), so add a comment `// Expected to fail for missing executables -- Phase 4 will add debug logging` instead of console.error.

    **3. Command projectRoot Refactoring:**
    For each command file (init, add, sync, status, clean, update), change the command function signature to accept an optional projectRoot parameter with default process.cwd():

    Before: `const projectRoot = process.cwd();`
    After: Accept `projectRoot = process.cwd()` in the options object or as a separate parameter.

    Recommended approach: Add `projectRoot?: string` to each command's options interface in types.ts, then:
    ```
    export async function initCommand(options: InitOptions): Promise<void> {
      const projectRoot = options.projectRoot || process.cwd();
      // ... rest unchanged
    }
    ```

    The CLI layer (Commander) does NOT pass projectRoot, so the default kicks in. Tests CAN pass projectRoot to control behavior. This is a MINIMAL signature change per research recommendations -- do NOT add a --root CLI flag.

    **4. Update context7-client.ts to use IMcpClient:**
    Modify queryViaMcp() to accept an optional IMcpClient parameter. Default to a new McpCliClient() instance. This allows tests to inject FakeMcpClient without mocking child_process. Similarly, update any function that calls mcp-client functions directly.

    **5. Verify existing behavior is preserved:**
    After all refactoring, run `bun run typecheck` to ensure type safety. Run `bun run build` to verify the build still works. The CLI should function identically -- refactoring is internal only.
  </action>
  <verify>
    1. `bun run typecheck` passes with zero errors
    2. `bun run build` succeeds
    3. `grep -r "catch {" src/lib/` shows no silent catches (except findInPath which has a comment)
    4. `grep "IMcpClient" src/lib/interfaces/mcp-client.ts` finds the interface
    5. `grep "projectRoot" src/commands/init.ts` shows the parameter
    6. All 6 command files accept projectRoot in their options
  </verify>
  <done>
    Source code is refactored for testability: IMcpClient interface extracted with McpCliClient and FakeMcpClient implementations, 5 silent exception catches replaced with console.error logging, all 6 CLI commands accept optional projectRoot parameter (defaulting to process.cwd()), and context7-client uses IMcpClient for MCP interactions. Build and typecheck pass. External CLI behavior is unchanged.
  </done>
</task>

</tasks>

<verification>
1. `bun test` discovers and runs the coverage-loader test
2. `bun run typecheck` passes
3. `bun run build` succeeds
4. All test helper files exist and export expected functions
5. All fixture files contain realistic data structures
6. No silent exception swallowing remains in src/lib/ (except documented findInPath)
7. IMcpClient interface exists with production and fake implementations
8. All 6 CLI commands accept optional projectRoot
</verification>

<success_criteria>
- `bun test --coverage` runs successfully and shows all src/lib/ modules in coverage output
- `scripts/check-coverage.ts` executes without crashing (low coverage expected -- tests come in Plans 02-04)
- `bun run typecheck` and `bun run build` both pass after refactoring
- Test helpers are importable and functional
- No regressions in CLI behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-01-SUMMARY.md`
</output>
