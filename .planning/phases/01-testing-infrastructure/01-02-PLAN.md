---
phase: 01-testing-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tests/unit/lib/config.test.ts
  - tests/unit/lib/templates.test.ts
  - tests/unit/lib/index-parser.test.ts
  - tests/unit/lib/fs-utils.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests for config module cover readConfig, writeConfig, createDefaultConfig, detectProjectType, detectDependencies, cleanVersion, getMajorVersion"
    - "Unit tests for templates module cover getTemplate, hasTemplate, listTemplates, getTemplatesByCategory, getTemplatesByPriority"
    - "Unit tests for index-parser module cover parseIndex, generateIndex, generateIndexBlock, extractIndexFromClaudeMd, updateClaudeMdIndex, buildIndexSections"
    - "Unit tests for fs-utils module cover ensureDir, removeDir, listDir, writeDocFile, readDocFile, readFrameworkDocs, calculateDocsSize, formatSize, updateGitignore"
    - "All tests use mock.module() for filesystem -- no real disk I/O"
    - "All tests pass when run with `bun test tests/unit/lib/`"
  artifacts:
    - path: "tests/unit/lib/config.test.ts"
      provides: "Config module unit tests"
      min_lines: 100
    - path: "tests/unit/lib/templates.test.ts"
      provides: "Templates module unit tests"
      min_lines: 60
    - path: "tests/unit/lib/index-parser.test.ts"
      provides: "Index parser unit tests"
      min_lines: 100
    - path: "tests/unit/lib/fs-utils.test.ts"
      provides: "FS utils unit tests"
      min_lines: 80
  key_links:
    - from: "tests/unit/lib/config.test.ts"
      to: "src/lib/config.ts"
      via: "dynamic import after mock.module"
      pattern: "import.*config"
    - from: "tests/unit/lib/config.test.ts"
      to: "tests/fixtures/config/valid-config.json"
      via: "fixture loading"
      pattern: "fixtures.*config"
    - from: "tests/unit/lib/index-parser.test.ts"
      to: "tests/fixtures/claude-md/"
      via: "fixture loading for CLAUDE.md samples"
      pattern: "fixtures.*claude-md"
---

<objective>
Write comprehensive unit tests for the four core data/logic modules: config, templates, index-parser, and fs-utils.

Purpose: These are the pure logic modules that form the foundation of PDI. Testing them first establishes patterns that the I/O module tests (Plan 03) and integration tests (Plan 04) will follow.

Output: Four test files in tests/unit/lib/ covering all exported functions with realistic fixtures.
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-CONTEXT.md
@.planning/phases/01-testing-infrastructure/01-RESEARCH.md
@.planning/phases/01-testing-infrastructure/01-01-SUMMARY.md
@src/lib/config.ts
@src/lib/templates.ts
@src/lib/index-parser.ts
@src/lib/fs-utils.ts
@src/lib/types.ts
@src/lib/constants.ts
@tests/helpers/setup.ts
@tests/helpers/factories.ts
@tests/helpers/mock-fs.ts
@tests/fixtures/config/valid-config.json
@tests/fixtures/package-json/cli-project.json
@tests/fixtures/claude-md/with-index.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for config and templates modules</name>
  <files>
    tests/unit/lib/config.test.ts
    tests/unit/lib/templates.test.ts
  </files>
  <action>
    Write unit tests for config.ts and templates.ts. Use mock.module("node:fs") and mock.module("node:fs/promises") BEFORE dynamic imports. Use fixtures from tests/fixtures/ and factories from tests/helpers/factories.ts.

    **config.test.ts -- test all exported functions:**

    `describe("getConfigPath")` -- returns correct path joining projectRoot + .claude-docs/config.json

    `describe("configExists")` -- returns true when file exists, false when not (mock existsSync)

    `describe("readConfig")`:
    - Returns parsed config when file exists with valid JSON (use valid-config.json fixture)
    - Returns null when config file doesn't exist
    - Throws Error with message when file has invalid JSON

    `describe("writeConfig")`:
    - Writes JSON to correct path
    - Creates directory if it doesn't exist
    - Verifies JSON is pretty-printed (2-space indent)

    `describe("createDefaultConfig")`:
    - Returns config with correct project name and type
    - Has empty frameworks object
    - Has null lastSync

    `describe("readPackageJson")`:
    - Returns parsed package.json when file exists (use fixture)
    - Returns null when file doesn't exist
    - Returns null when file has invalid JSON (verify console.error is called -- refactored in Plan 01)

    `describe("detectProjectType")`:
    - Returns "cli" when package.json has bin field (use cli-project.json fixture)
    - Returns "frontend" when has react dependency (use frontend-project.json)
    - Returns "fullstack" when has both backend and frontend deps (use fullstack-project.json)
    - Returns "library" when has exports/main but no app indicators
    - Returns "backend" as default

    `describe("detectDependencies")`:
    - Detects known frameworks from dependencies
    - Detects from devDependencies
    - Skips unknown packages
    - Deduplicates framework detections

    `describe("cleanVersion")`:
    - Removes ^ prefix: "^1.2.3" -> "1.2.3"
    - Removes ~ prefix: "~1.2.3" -> "1.2.3"
    - Removes >= prefix: ">=1.2.3" -> "1.2.3"
    - Returns plain version unchanged: "1.2.3" -> "1.2.3"

    `describe("getMajorVersion")`:
    - Returns "X.x" for major > 0: "4.2.1" -> "4.x"
    - Returns "0.X" for major = 0: "0.3.0" -> "0.3"

    `describe("updateFrameworkInConfig")`, `describe("removeFrameworkFromConfig")`, `describe("updateSyncTime")`:
    - Verify immutable updates (returns new object)
    - Verify correct field changes

    **templates.test.ts -- test registry functions:**

    `describe("getTemplate")`:
    - Returns template for known names (hono, drizzle, zod, react, etc.)
    - Returns undefined for unknown names

    `describe("hasTemplate")`:
    - Returns true for all 10 built-in templates
    - Returns false for unknown names

    `describe("listTemplates")`:
    - Returns array with 10 templates
    - Each template has required fields (name, displayName, version, category, structure)

    `describe("getTemplatesByCategory")`:
    - "backend" returns hono
    - "frontend" returns react, tanstack-query, tanstack-router
    - "database" returns drizzle

    `describe("getTemplatesByPriority")`:
    - "P0" returns hono, drizzle, better-auth, zod
    - "P1" returns the remaining 6

    `describe("FRAMEWORK_TEMPLATES")`:
    - Every template has a non-empty structure with at least one category
    - Every template has a libraryId
    - All template names match their key in the registry
  </action>
  <verify>
    1. `bun test tests/unit/lib/config.test.ts` -- all tests pass
    2. `bun test tests/unit/lib/templates.test.ts` -- all tests pass
    3. No test touches the real filesystem (mock.module is called before imports)
  </verify>
  <done>
    config.test.ts covers all 12 exported functions with realistic fixtures and edge cases. templates.test.ts covers all 5 registry functions and validates all 10 built-in template structures. All tests pass with mocked filesystem.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for index-parser and fs-utils modules</name>
  <files>
    tests/unit/lib/index-parser.test.ts
    tests/unit/lib/fs-utils.test.ts
  </files>
  <action>
    Write unit tests for index-parser.ts and fs-utils.ts. Same mocking patterns as Task 1.

    **index-parser.test.ts -- test all exported functions:**

    `describe("parseIndex")`:
    - Parses section header: "[Framework Docs]|root:.claude-docs/frameworks" extracts title and root
    - Parses critical instructions: "|CRITICAL:Read docs before coding"
    - Parses entry: "|hono@4.x|api:{app.mdx,routing.mdx}|patterns:{error-handling.mdx}" extracts package, version, categories with files
    - Parses multiple sections
    - Handles empty input (returns empty array)
    - Ignores malformed lines

    `describe("generateIndex")`:
    - Round-trips with parseIndex (generate -> parse -> generate yields same output)
    - Generates correct format for single section with one entry
    - Generates correct format for multiple sections with critical instructions

    `describe("generateIndexBlock")`:
    - Includes PDI_BEGIN_MARKER and PDI_END_MARKER
    - Includes MCP fallback comment when libraryMappings provided
    - Omits MCP fallback comment when no mappings

    `describe("extractIndexFromClaudeMd")`:
    - Extracts content between pdi:begin and pdi:end markers (use with-index.md fixture)
    - Returns null when no markers present (use without-index.md fixture)
    - Returns null when markers are in wrong order

    `describe("updateClaudeMdIndex")`:
    - Creates new CLAUDE.md when file doesn't exist
    - Updates existing index when markers present
    - Appends index when CLAUDE.md exists but has no markers
    - Preserves content before and after markers

    `describe("buildIndexSections")`:
    - Builds framework section from framework data
    - Builds internal section from internal data
    - Returns empty array when no data
    - Includes default critical instructions

    `describe("calculateIndexSize")`:
    - Returns size in KB

    **fs-utils.test.ts -- test all exported functions (mocked filesystem):**

    `describe("ensureDir")`:
    - Creates directory when it doesn't exist
    - Does nothing when directory exists
    - Uses recursive: true

    `describe("removeDir")`:
    - Removes directory when it exists
    - Does nothing when directory doesn't exist

    `describe("listDir")`:
    - Returns file list when directory exists
    - Returns empty array when directory doesn't exist

    `describe("listDirRecursive")`:
    - Returns all files recursively
    - Returns empty array when directory doesn't exist

    `describe("writeDocFile")`:
    - Creates correct file path from framework/category/filename
    - Ensures parent directory exists
    - Writes content with utf-8 encoding

    `describe("readDocFile")`:
    - Returns content when file exists
    - Returns null when file doesn't exist

    `describe("readFrameworkDocs")`:
    - Returns categorized docs structure
    - Only includes .mdx files
    - Returns empty object for missing framework

    `describe("calculateDocsSize")`:
    - Returns framework sizes and total
    - Only counts .mdx files
    - Returns zeros when docs path doesn't exist

    `describe("formatSize")`:
    - "500" -> "500B"
    - "1024" -> "1.0KB"
    - "1536" -> "1.5KB"
    - "1048576" -> "1.00MB"

    `describe("updateGitignore")`:
    - Creates .gitignore with cache entry when file doesn't exist
    - Appends cache entry when file exists but doesn't have it
    - Does nothing when entry already present (returns false)
  </action>
  <verify>
    1. `bun test tests/unit/lib/index-parser.test.ts` -- all tests pass
    2. `bun test tests/unit/lib/fs-utils.test.ts` -- all tests pass
    3. `bun test tests/unit/lib/` -- all 4 test files pass together (no state leaks)
  </verify>
  <done>
    index-parser.test.ts covers all 8 exported functions including round-trip parsing, CLAUDE.md operations, and index building. fs-utils.test.ts covers all 13 exported functions with mocked filesystem operations. All tests pass individually and as a suite without state leaks.
  </done>
</task>

</tasks>

<verification>
1. `bun test tests/unit/lib/` runs all 4 test files and all tests pass
2. No test creates, reads, or modifies real files on disk
3. Coverage for config.ts, templates.ts, index-parser.ts, fs-utils.ts is visible in `bun test --coverage` output
4. Each test file uses fixtures from tests/fixtures/ (not minimal invented data)
5. Each test file uses mock.module() before importing tested modules
</verification>

<success_criteria>
- All 4 unit test files pass with `bun test tests/unit/lib/`
- Coverage for config, templates, index-parser, fs-utils modules is above 80% each (visible in coverage output)
- Tests use realistic fixtures and factory functions
- No filesystem, network, or external state dependencies in any test
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-02-SUMMARY.md`
</output>
