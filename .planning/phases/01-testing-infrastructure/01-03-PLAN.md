---
phase: 01-testing-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tests/unit/lib/context7-client.test.ts
  - tests/unit/lib/mcp-client.test.ts
  - tests/unit/lib/context7.test.ts
  - tests/unit/lib/index-utils.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests for context7-client cover queryContext7, searchLibrary, checkAvailability, resetClients with HTTP and MCP paths"
    - "Unit tests for mcp-client cover extractContext7Content with all response formats (string, array, nested objects)"
    - "Unit tests for context7.ts cover queryViaHttp, queryViaMcp, and the fallback logic (HTTP -> MCP -> offline)"
    - "Unit tests for index-utils cover buildFrameworksIndex, buildInternalIndex, updateClaudeMdFromConfig"
    - "HTTP tests use spyOn(global, 'fetch') -- validates URLs and payloads per user decision"
    - "MCP tests use FakeMcpClient from IMcpClient interface -- no subprocess mocking"
    - "All tests pass when run with `bun test tests/unit/lib/`"
  artifacts:
    - path: "tests/unit/lib/context7-client.test.ts"
      provides: "Context7 unified client unit tests"
      min_lines: 100
    - path: "tests/unit/lib/mcp-client.test.ts"
      provides: "MCP client unit tests (content extraction focus)"
      min_lines: 60
    - path: "tests/unit/lib/context7.test.ts"
      provides: "Context7 HTTP/MCP logic tests"
      min_lines: 80
    - path: "tests/unit/lib/index-utils.test.ts"
      provides: "Index utilities unit tests"
      min_lines: 40
  key_links:
    - from: "tests/unit/lib/context7-client.test.ts"
      to: "tests/helpers/mock-fetch.ts"
      via: "fetch interception"
      pattern: "createFetchMock|spyOn.*fetch"
    - from: "tests/unit/lib/context7-client.test.ts"
      to: "tests/helpers/mock-mcp.ts"
      via: "FakeMcpClient injection"
      pattern: "FakeMcpClient"
    - from: "tests/unit/lib/context7-client.test.ts"
      to: "tests/fixtures/context7/"
      via: "fixture data for responses"
      pattern: "fixtures.*context7"
---

<objective>
Write comprehensive unit tests for the I/O-dependent modules: context7-client, mcp-client, context7, and index-utils.

Purpose: These modules handle external I/O (HTTP fetch, MCP subprocess, filesystem) and are the most critical to mock correctly. Testing them validates that the mocking strategy from Plan 01 works end-to-end.

Output: Four test files covering all I/O module functions with proper fetch spying and FakeMcpClient injection.
</objective>

<execution_context>
@/Users/sleepy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sleepy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-infrastructure/01-CONTEXT.md
@.planning/phases/01-testing-infrastructure/01-RESEARCH.md
@.planning/phases/01-testing-infrastructure/01-01-SUMMARY.md
@src/lib/context7-client.ts
@src/lib/mcp-client.ts
@src/lib/context7.ts
@src/lib/index-utils.ts
@src/lib/types.ts
@src/lib/interfaces/mcp-client.ts
@tests/helpers/mock-fetch.ts
@tests/helpers/mock-mcp.ts
@tests/helpers/factories.ts
@tests/fixtures/context7/search-library.json
@tests/fixtures/context7/query-docs.json
@tests/fixtures/context7/error-response.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for context7-client and context7 modules</name>
  <files>
    tests/unit/lib/context7-client.test.ts
    tests/unit/lib/context7.test.ts
  </files>
  <action>
    Write unit tests for the Context7 unified client and the Context7 HTTP module. These are the most complex modules with HTTP fetch, MCP fallback, caching, and redirect handling.

    **CRITICAL MOCKING ORDER:** Call mock.module() for node:fs, node:fs/promises, and the @upstash/context7-sdk BEFORE any dynamic imports. Use spyOn(global, 'fetch') in beforeEach for HTTP interception.

    **context7-client.test.ts -- test the unified client:**

    `describe("queryContext7 (unified)")`:
    - When HTTP client available and succeeds: returns HTTP result with source: "http"
    - When HTTP client available but fails, MCP available: falls back to MCP, returns source: "mcp"
    - When HTTP fails and MCP fails: returns error with source: "none"
    - When no API key and no MCP: returns offline error
    - When config.preferMcp is true: tries MCP first

    `describe("queryViaHttp")` (test indirectly through queryContext7):
    - Sends correct fetch request to Context7 API
    - Returns formatted docs content when successful
    - Handles library_redirected error by resolving library ID and retrying
    - Returns error for non-redirect failures

    `describe("searchLibrary")`:
    - Returns {id, name} when search succeeds
    - Returns null when no results
    - Returns null when client unavailable (no API key)
    - Returns null on error (verify console.error is called after refactoring)

    `describe("checkAvailability")`:
    - Returns http: true, mcp: false when only API key set
    - Returns http: false, mcp: true when only MCP available
    - Returns both true when both available
    - Returns both false when neither available
    - Returns correct recommended source and message

    `describe("resetClients")`:
    - Clears httpClient, httpClientApiKey, libraryIdCache
    - Next call to queryContext7 creates fresh client

    **context7.ts tests (if this module has additional functions beyond what's in context7-client.ts):**
    Note: Looking at the codebase, context7.ts re-exports from context7-client.ts and mcp-client.ts. If it has its own functions, test those. If it's purely re-exports, a minimal test confirming exports exist is sufficient.

    **Mocking the @upstash/context7-sdk:**
    The Context7 class from the SDK is used internally. Mock it with mock.module():
    ```
    mock.module("@upstash/context7-sdk", () => ({
      Context7: mock(function(config) {
        this.getContext = mock(async () => fixtureData);
        this.searchLibrary = mock(async () => searchResults);
      })
    }));
    ```
    Use fixture data from tests/fixtures/context7/ for realistic response shapes.

    **Fetch spy approach for direct HTTP tests:**
    Use createFetchMock from tests/helpers/mock-fetch.ts to intercept fetch calls. Validate:
    - Correct URL patterns (matching Context7 API endpoints)
    - Request method and headers
    - Request body content (validates payloads, not just return values -- per user decision)
    Return fixture data from tests/fixtures/context7/.
  </action>
  <verify>
    1. `bun test tests/unit/lib/context7-client.test.ts` -- all tests pass
    2. `bun test tests/unit/lib/context7.test.ts` -- all tests pass
    3. No real HTTP requests made (no network needed)
    4. No real MCP subprocess spawned
    5. Fetch spy validates URLs and payloads in at least 2 tests
  </verify>
  <done>
    context7-client.test.ts covers the unified query flow (HTTP primary, MCP fallback, offline), search, availability checking, and client reset. context7.test.ts covers any module-specific functions. All HTTP interactions use spyOn(global, 'fetch') with URL/payload validation. All MCP interactions use FakeMcpClient.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for mcp-client and index-utils modules</name>
  <files>
    tests/unit/lib/mcp-client.test.ts
    tests/unit/lib/index-utils.test.ts
  </files>
  <action>
    Write unit tests for mcp-client.ts (focusing on content extraction and testable functions) and index-utils.ts.

    **mcp-client.test.ts:**

    The mcp-client.ts module has functions that spawn child processes (findInPath, findMcpCliInfo, isMcpCliAvailable, executeMcpCliCall, queryContext7, resolveContext7Library). Testing the subprocess-dependent functions directly would require mocking child_process which is unreliable in Bun (per research). Instead:

    Focus on the testable exported functions:

    `describe("extractContext7Content")`:
    - Parses JSON string response: `'"hello"'` -> `"hello"`
    - Parses JSON array response with text blocks: `[{text: "content"}]` -> `"content"`
    - Parses JSON array response with content blocks: `[{content: "data"}]` -> `"data"`
    - Parses JSON object with content field: `{content: "data"}` -> `"data"`
    - Parses JSON object with content array (MCP format): `{content: [{text: "a"}, {text: "b"}]}` -> `"a\n\nb"`
    - Parses JSON object with result field: `{result: "data"}` -> `"data"`
    - Parses JSON object with text field: `{text: "data"}` -> `"data"`
    - Parses JSON object with documentation field: `{documentation: "data"}` -> `"data"`
    - Returns raw string when not valid JSON
    - Handles complex nested response from fixture (mcp/query-result.json)

    `describe("resetMcpCliCache")`:
    - Resets mcpCliAvailable and mcpCliInfo to null
    - After reset, isMcpCliAvailable re-checks (mock child_process for this)

    `describe("MCPResult type")`:
    - Verify the exported type shape with type tests

    For isMcpCliAvailable, queryContext7, resolveContext7Library: These are tested indirectly through the IMcpClient interface (McpCliClient wraps them). The FakeMcpClient handles test scenarios. Add a note that subprocess-level testing is deferred to integration tests or Phase 2 CI.

    **index-utils.test.ts:**

    `describe("buildFrameworksIndex")`:
    - Builds index from frameworks config and doc files
    - Maps DocFile names to category arrays
    - Handles framework with no docs (empty categories)

    `describe("buildInternalIndex")`:
    - Builds index from internal docs
    - Maps DocFile names to category arrays
    - Returns empty object when no docs

    `describe("updateClaudeMdFromConfig")`:
    - Reads all docs, builds index, updates CLAUDE.md (mock filesystem)
    - Returns correct indexSize and created flag
    - Uses library mappings from config.mcp
    - Handles empty frameworks object
  </action>
  <verify>
    1. `bun test tests/unit/lib/mcp-client.test.ts` -- all tests pass
    2. `bun test tests/unit/lib/index-utils.test.ts` -- all tests pass
    3. `bun test tests/unit/lib/` -- all 8 test files pass together without state leaks
    4. extractContext7Content tests cover all documented response formats
  </verify>
  <done>
    mcp-client.test.ts covers extractContext7Content with all 10+ response format variants and resetMcpCliCache. index-utils.test.ts covers buildFrameworksIndex, buildInternalIndex, and updateClaudeMdFromConfig with mocked filesystem. All 8 unit test files pass together as a suite.
  </done>
</task>

</tasks>

<verification>
1. `bun test tests/unit/lib/` runs all 8 test files and all tests pass
2. Coverage for context7-client.ts, mcp-client.ts, context7.ts, index-utils.ts is visible in output
3. HTTP tests use spyOn(global, 'fetch') -- no real network calls
4. MCP tests use FakeMcpClient -- no real subprocess spawning
5. Fixtures from tests/fixtures/context7/ and tests/fixtures/mcp/ are used for realistic data
</verification>

<success_criteria>
- All 8 unit test files (4 from Plan 02 + 4 from this plan) pass with `bun test tests/unit/lib/`
- Coverage for context7-client, mcp-client, context7, index-utils modules targets 80%+
- extractContext7Content has tests for every documented response format
- No tests depend on network, filesystem, or MCP subprocess
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-infrastructure/01-03-SUMMARY.md`
</output>
